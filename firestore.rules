rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check if user is authenticated (including anonymous)
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // Helper function to check if user is therapist
    function isTherapist() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'therapist';
    }
    
    // Helper function to check if user is client
    function isClient() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'client';
    }
    
    // Helper to check if user owns the document
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }

    // Users collection - Strict access control
    match /users/{uid} {
      // Users can read their own data (single document)
      allow get: if isOwner(uid);

      // CRITICAL: Allow any authenticated user (including anonymous who just signed in)
      // to query users collection for username checks and therapist browsing
      allow list: if request.auth != null;

      // Allow creation if user is creating their own document
      // OR if user is anonymous and creating their first profile
      allow create: if request.auth != null &&
                      request.auth.uid == uid &&
                      request.resource.data.uid == uid &&
                      request.resource.data.role == 'client';

      // Users can update their own profile (excluding role)
      allow update: if isOwner(uid) &&
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'uid']);

      // Therapists can update their therapistProfile field
      allow update: if isOwner(uid) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['therapistProfile', 'updatedAt']);

      // Admins can do everything (but need to check if user doc exists first)
      allow read, write: if request.auth != null &&
                           exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
                           get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';

      // No one else can delete users
      allow delete: if false;
    }

    // Therapist profiles are now stored in users collection with therapistProfile field

    // Sessions collection - Strict participant access
    match /sessions/{sessionId} {
      // Only session participants can read individual documents
      allow get: if isAuthenticated() && 
                   (request.auth.uid == resource.data.therapistId || 
                    request.auth.uid == resource.data.clientId);
      
      // Allow list queries for authenticated users
      // This is safe because getUserSessions filters by clientId/therapistId matching user's ID
      // So users can only query their own sessions, even with this permissive rule
      // This fixes the issue where new accounts with no sessions get permission denied errors
      allow list: if isAuthenticated();
      
      // Clients can create sessions (during booking)
      allow create: if isAuthenticated() && 
                      request.resource.data.clientId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['therapistId', 'clientId', 'sessionType', 'status', 'scheduledTime']);
      
      // Participants can update limited fields only
      allow update: if isAuthenticated() && 
                      (request.auth.uid == resource.data.therapistId || 
                       request.auth.uid == resource.data.clientId) &&
                      request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['status', 'startTime', 'endTime', 'notes', 'updatedAt']);
      
      // Admins can read all sessions
      allow get, list: if isAdmin();
      
      // No one can delete sessions
      allow delete: if false;
    }

    // Chat messages collection - Immutable after creation
    match /chatMessages/{messageId} {
      // Only session participants can read messages
      allow read: if isAuthenticated() && 
                    exists(/databases/$(database)/documents/sessions/$(resource.data.sessionId)) &&
                    (request.auth.uid == get(/databases/$(database)/documents/sessions/$(resource.data.sessionId)).data.therapistId ||
                     request.auth.uid == get(/databases/$(database)/documents/sessions/$(resource.data.sessionId)).data.clientId);
      
      // Participants can create messages only for their sessions
      allow create: if isAuthenticated() && 
                      request.resource.data.senderId == request.auth.uid &&
                      exists(/databases/$(database)/documents/sessions/$(request.resource.data.sessionId)) &&
                      (request.auth.uid == get(/databases/$(database)/documents/sessions/$(request.resource.data.sessionId)).data.therapistId ||
                       request.auth.uid == get(/databases/$(database)/documents/sessions/$(request.resource.data.sessionId)).data.clientId);
      
      // Messages are immutable - no updates or deletes
      allow update, delete: if false;
    }

    // Session participants collection
    match /sessionParticipants/{participantId} {
      // Participants can read their own records
      allow read: if isAuthenticated() && 
                    request.auth.uid == resource.data.userId;
      
      // Participants can create their own participation record
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid;
      
      // Participants can update their own status
      allow update: if isAuthenticated() && 
                      request.auth.uid == resource.data.userId &&
                      request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['isOnline', 'leftAt']);
      
      // Admins can read all
      allow read: if isAdmin();
      
      // No deletes
      allow delete: if false;
    }

    // Bookings collection - Restricted access
    match /bookings/{bookingId} {
      // Clients can read their own bookings (individual document)
      allow get: if isAuthenticated() && 
                   request.auth.uid == resource.data.clientId;
      
      // Therapists can read bookings assigned to them (individual document)
      allow get: if isAuthenticated() && 
                   request.auth.uid == resource.data.therapistId;
      
      // Allow authenticated users to list/query bookings
      allow list: if isAuthenticated();
      
      // Clients can create their own bookings
      allow create: if isAuthenticated() && 
                      request.resource.data.clientId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['therapistId', 'clientId', 'sessionTime', 'serviceType', 'amount']);
      
      // Only allow updates to specific fields by participants
      allow update: if isAuthenticated() && 
                      (request.auth.uid == resource.data.clientId || 
                       request.auth.uid == resource.data.therapistId) &&
                      request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['status', 'notes', 'updatedAt']);
      
      // Admins can read all bookings
      allow read: if isAdmin();
      
      // No one can delete bookings
      allow delete: if false;
    }

    // Payments collection - clients create, admins manage payouts
    match /payments/{paymentId} {
      // Clients can read their own payments
      allow read: if isAuthenticated() && 
                    request.auth.uid == resource.data.clientId;
      
      // Therapists can read payments for their sessions
      allow read: if isAuthenticated() && 
                    request.auth.uid == resource.data.therapistId;
      
      // Admins can read all payments
      allow read: if isAdmin();

      // Clients can create their own payment records after successful checkout
      allow create: if isAuthenticated() &&
                     request.resource.data.clientId == request.auth.uid &&
                     request.resource.data.keys().hasAll(['bookingId', 'clientId', 'therapistId', 'amount', 'currency', 'paymentMethod', 'paymentStatus', 'orderId', 'finalAmount', 'payoutStatus']);

      // Admins can update payout-related fields for any payment
      allow update: if isAdmin() &&
                     request.resource.data.diff(resource.data).affectedKeys()
                     .hasOnly(['payoutStatus', 'payoutDate', 'therapistPayoutAmount', 'updatedAt']);

      // No deletes from client side
      allow delete: if false;
    }

    // Therapist availability collection
    match /therapistAvailability/{therapistId} {
      // Anyone authenticated can read availability (for booking)
      allow read: if isAuthenticated();

      // Therapists can manage their own availability, OR
      // Authenticated users can update availability (for booking system)
      // This allows the booking process to mark slots as booked
      allow write: if isOwner(therapistId) || isAuthenticated();

      // Admins can read all
      allow read: if isAdmin();
      
      // No deletes
      allow delete: if false;
    }

    // Therapist settings collection
    match /therapistSettings/{therapistId} {
      // Only the therapist can read/write their own settings
      allow read, write: if isOwner(therapistId);
      
      // Admins can read all
      allow read: if isAdmin();
    }

    // Notification settings collection
    match /notificationSettings/{therapistId} {
      // Only the therapist can manage their notification settings
      allow read, write: if isOwner(therapistId);
      
      // Admins can read all
      allow read: if isAdmin();
    }

    // Email notifications collection - System managed
    match /emailNotifications/{notificationId} {
      // Only admins can read notifications
      allow read: if isAdmin();
      
      // Only Cloud Functions can write (no client-side access)
      allow write: if false;
    }

    // Time slots collection
    match /timeSlots/{slotId} {
      // Anyone authenticated can read slots
      allow read: if isAuthenticated();
      
      // Therapists can manage their own slots
      allow write: if isAuthenticated() && 
                     request.resource.data.therapistId == request.auth.uid;
      
      // Admins can read all
      allow read: if isAdmin();
    }

    // Counters collection - for sequential integer IDs
    match /counters/{counterType} {
      // Anyone authenticated can read counters (for getting current count)
      allow read: if isAuthenticated();

      // Only allow creating/updating counters through transactions
      // This is handled by the getNextId function which uses transactions
      // For safety, we allow authenticated users to update counters
      // (The transaction logic ensures atomicity)
      allow write: if isAuthenticated();
    }

    // Error logs collection - Admin only access for monitoring
    match /error_logs/{logId} {
      // Only admins can read error logs
      allow read: if isAdmin();

      // Allow system/server-side writes only (no client writes)
      allow write: if false;
    }

    // System configuration collection
    match /systemConfig/{configId} {
      // Authenticated users can read system configuration (for session timing, etc.)
      allow read: if isAuthenticated();
      // Only admins can write system configuration
      allow write: if isAdmin();

      // No deletes
      allow delete: if false;
    }

    // Default deny all other collections and documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}